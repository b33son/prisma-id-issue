"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rules_1 = require("./rules");
const validation_1 = require("./validation");
/**
 *
 * @param x
 *
 * Makes sure that a certain field is a rule.
 *
 */
function isRule(x) {
    return x instanceof rules_1.Rule;
}
exports.isRule = isRule;
/**
 *
 * @param x
 *
 * Makes sure that a certain field is a logic rule.
 *
 */
function isLogicRule(x) {
    return x instanceof rules_1.LogicRule;
}
exports.isLogicRule = isLogicRule;
/**
 *
 * @param x
 *
 * Makes sure that a certain field is a rule or a logic rule.
 *
 */
function isRuleFunction(x) {
    return isRule(x) || isLogicRule(x);
}
exports.isRuleFunction = isRuleFunction;
/**
 *
 * @param x
 *
 * Determines whether a certain field is rule field map or not.
 *
 */
function isRuleFieldMap(x) {
    return (typeof x === 'object' &&
        Object.values(x).every(rule => isRuleFunction(rule)));
}
exports.isRuleFieldMap = isRuleFieldMap;
/**
 *
 * @param obj
 * @param func
 *
 * Flattens object of particular type by checking if the leaf
 * evaluates to true from particular function.
 *
 */
function flattenObjectOf(obj, func) {
    const values = Object.keys(obj).reduce((acc, key) => {
        if (func(obj[key])) {
            return [...acc, obj[key]];
        }
        else if (typeof obj[key] === 'object' && !func(obj[key])) {
            return [...acc, ...flattenObjectOf(obj[key], func)];
        }
        else {
            return acc;
        }
    }, []);
    return values;
}
/**
 *
 * @param ruleTree
 *
 * Extracts rules from rule tree.
 *
 */
function extractRules(ruleTree) {
    const resolvers = flattenObjectOf(ruleTree, isRuleFunction);
    const rules = resolvers.reduce((rules, rule) => {
        switch (rule.constructor) {
            case rules_1.Rule: {
                return [...rules, rule];
            }
            case rules_1.LogicRule: {
                return [...rules, rule.getRules()];
            }
            default: {
                return rules;
            }
        }
    }, []);
    return rules;
}
exports.extractRules = extractRules;
/**
 *
 * @param ruleTree
 *
 * Validates the rule tree declaration by checking references of rule
 * functions. We deem rule tree valid if no two rules with the same name point
 * to different rules.
 *
 */
function validateRules(ruleTree) {
    const rules = extractRules(ruleTree);
    rules.reduce((_map, rule) => {
        if (!_map.has(rule.name)) {
            return _map.set(rule.name, rule);
        }
        else if (!_map.get(rule.name).equals(rule)) {
            throw new validation_1.ValidationError(`Rule "${rule.name}" seems to point at two different things.`);
        }
        else {
            return _map;
        }
    }, new Map());
    return ruleTree;
}
exports.validateRules = validateRules;
//# sourceMappingURL=utils.js.map