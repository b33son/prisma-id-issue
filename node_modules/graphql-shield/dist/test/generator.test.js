"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = require("ava");
const graphql_1 = require("graphql");
const graphql_middleware_1 = require("graphql-middleware");
const graphql_tools_1 = require("graphql-tools");
const __1 = require("../");
ava_1.default('Generator - whitelist permissions.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      check: String
      allow: Test
      deny: Test
    }

    type Test {
      check: String
      allow: String
      deny: String
    }
  `;
    const resolvers = {
        Query: {
            check: () => 'pass',
            allow: () => ({}),
            deny: () => ({}),
        },
        Test: {
            check: () => 'pass',
            allow: () => 'pass',
            deny: () => 'pass',
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Permissions
    const permissions = __1.shield({
        Query: {
            allow: __1.allow,
        },
        Test: {
            allow: __1.allow,
        },
    }, {
        whitelist: true,
        debug: true,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      check
      allow {
        check
        allow
        deny
      }
      deny {
        check
        allow
        deny
      }
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.deepEqual(res.data, {
        check: null,
        allow: {
            check: null,
            allow: 'pass',
            deny: null,
        },
        deny: null,
    });
    t.not(res.errors.length, 0);
}));
ava_1.default('Generator - blacklist permissions.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      check: String
      allow: Test
      deny: Test
    }

    type Test {
      check: String
      allow: String
      deny: String
    }
  `;
    const resolvers = {
        Query: {
            check: () => 'pass',
            allow: () => ({}),
            deny: () => ({}),
        },
        Test: {
            check: () => 'pass',
            allow: () => 'pass',
            deny: () => 'pass',
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Permissions
    const permissions = __1.shield({
        Query: {
            deny: __1.deny,
        },
        Test: {
            deny: __1.deny,
        },
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      check
      allow {
        check
        allow
        deny
      }
      deny {
        check
        allow
        deny
      }
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.deepEqual(res.data, {
        check: 'pass',
        allow: {
            check: 'pass',
            allow: 'pass',
            deny: null,
        },
        deny: null,
    });
    t.not(res.errors.length, 0);
}));
ava_1.default('Generator - fallbackRule deny permissions.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      check: String
      allow: Test
      deny: Test
    }

    type Test {
      check: String
      allow: String
      deny: String
    }
  `;
    const resolvers = {
        Query: {
            check: () => 'pass',
            allow: () => ({}),
            deny: () => ({}),
        },
        Test: {
            check: () => 'pass',
            allow: () => 'pass',
            deny: () => 'pass',
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Permissions
    const permissions = __1.shield({
        Query: {
            allow: __1.allow,
        },
        Test: {
            allow: __1.allow,
        },
    }, {
        fallbackRule: __1.deny,
        debug: true,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      check
      allow {
        check
        allow
        deny
      }
      deny {
        check
        allow
        deny
      }
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.deepEqual(res.data, {
        check: null,
        allow: {
            check: null,
            allow: 'pass',
            deny: null,
        },
        deny: null,
    });
    t.not(res.errors.length, 0);
}));
ava_1.default('Generator - fallbackRule allow permissions.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      check: String
      allow: Test
      deny: Test
    }

    type Test {
      check: String
      allow: String
      deny: String
    }
  `;
    const resolvers = {
        Query: {
            check: () => 'pass',
            allow: () => ({}),
            deny: () => ({}),
        },
        Test: {
            check: () => 'pass',
            allow: () => 'pass',
            deny: () => 'pass',
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Permissions
    const permissions = __1.shield({
        Query: {
            deny: __1.deny,
        },
        Test: {
            deny: __1.deny,
        },
    }, { fallbackRule: __1.allow });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      check
      allow {
        check
        allow
        deny
      }
      deny {
        check
        allow
        deny
      }
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.deepEqual(res.data, {
        check: 'pass',
        allow: {
            check: 'pass',
            allow: 'pass',
            deny: null,
        },
        deny: null,
    });
    t.not(res.errors.length, 0);
}));
ava_1.default('Generator - fallbackRule custom permissions.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      check: String
      allow: Test
      deny: Test
    }
     type Test {
      check: String
      allow: String
      deny: String
    }
  `;
    const resolvers = {
        Query: {
            check: () => 'pass',
            allow: () => ({}),
            deny: () => ({}),
        },
        Test: {
            check: () => 'pass',
            allow: () => 'pass',
            deny: () => 'pass',
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    const customRule = __1.rule()((parent, args, ctx) => {
        return ctx.allow === true;
    });
    // Permissions
    const permissions = __1.shield({
        Query: {
            allow: __1.allow,
            deny: __1.deny,
        },
        Test: {
            allow: __1.allow,
            deny: __1.deny,
        },
    }, {
        fallbackRule: customRule,
        debug: true,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      check
      allow {
        check
        allow
        deny
      }
      deny {
        check
        allow
        deny
      }
    }
  `;
    const ctx1 = { allow: true };
    const res = yield graphql_1.graphql(schemaWithPermissions, query, undefined, ctx1);
    t.deepEqual(res.data, {
        check: 'pass',
        allow: {
            check: 'pass',
            allow: 'pass',
            deny: null,
        },
        deny: null,
    });
    t.not(res.errors.length, 0);
    const ctx2 = { allow: false };
    const res2 = yield graphql_1.graphql(schemaWithPermissions, query, undefined, ctx2);
    t.deepEqual(res2.data, {
        check: null,
        allow: {
            check: null,
            allow: 'pass',
            deny: null,
        },
        deny: null,
    });
    t.not(res2.errors.length, 0);
}));
ava_1.default('Generator - throws if both whitelist and fallbackRule are specified.', (t) => __awaiter(this, void 0, void 0, function* () {
    t.throws(() => {
        __1.shield({
            Query: {
                deny: __1.deny,
            },
            Test: {
                deny: __1.deny,
            },
        }, { whitelist: true, fallbackRule: __1.allow });
    }, {
        message: 'You specified both `whitelist` and `fallbackRule`. Please use one or the other.',
    });
}));
ava_1.default('Generator generates schema wide middleware correctly.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String
      type: Test
    }

    type Test {
      typeTest: String
    }
  `;
    const resolvers = {
        Query: {
            test: () => 'pass',
        },
        Test: {
            typeTest: () => 'pass',
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    const permissions = __1.shield(__1.deny);
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
      type {
        typeTest
      }
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.deepEqual(res.data, {
        test: null,
        type: null,
    });
    t.not(res.errors.length, 0);
}));
//# sourceMappingURL=generator.test.js.map