"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = require("ava");
const graphql_1 = require("graphql");
const graphql_middleware_1 = require("graphql-middleware");
const graphql_tools_1 = require("graphql-tools");
const index_1 = require("../index");
ava_1.default('Error in resolver resolves in fallback.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String!
    }
  `;
    const resolvers = {
        Query: {
            test: () => {
                throw new Error();
            },
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Fallback
    const fallback = new Error('fallback');
    // Permissions
    const permissions = index_1.shield({
        Query: index_1.allow,
    }, {
        fallback,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.is(res.data, null);
    t.is(res.errors[0].message, fallback.message);
}));
ava_1.default('Error in rule resolves in fallback.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String!
    }
  `;
    const resolvers = {
        Query: {
            test: () => 'pass',
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Fallback
    const fallback = new Error('fallback');
    // Permissions
    const allow = index_1.rule()(() => {
        throw new Error();
    });
    const permissions = index_1.shield({
        Query: allow,
    }, {
        fallback,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.is(res.data, null);
    t.is(res.errors[0].message, fallback.message);
}));
ava_1.default('Error in resolver resolves in fallback error.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String!
    }
  `;
    const resolvers = {
        Query: {
            test: () => {
                throw new Error();
            },
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Fallback
    const fallbackError = new Error('fallback');
    // Permissions
    const permissions = index_1.shield({
        Query: index_1.allow,
    }, {
        fallbackError,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.is(res.data, null);
    t.is(res.errors[0].message, fallbackError.message);
}));
ava_1.default('Error in rule resolves in fallback error.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String!
    }
  `;
    const resolvers = {
        Query: {
            test: () => 'pass',
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Fallback
    const fallbackError = new Error('fallback');
    // Permissions
    const allow = index_1.rule()(() => {
        throw new Error();
    });
    const permissions = index_1.shield({
        Query: allow,
    }, {
        fallbackError,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.is(res.data, null);
    t.is(res.errors[0].message, fallbackError.message);
}));
ava_1.default('Error in resolver with allowed external errors resolves in external error.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String!
    }
  `;
    const resolvers = {
        Query: {
            test: () => {
                throw new Error('external');
            },
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Permissions
    const permissions = index_1.shield({
        Query: index_1.allow,
    }, {
        allowExternalErrors: true,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.is(res.data, null);
    t.is(res.errors[0].message, 'external');
}));
ava_1.default('Error in rule with allowed external errors returns fallback.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String!
    }
  `;
    const resolvers = {
        Query: {
            test: () => 'pass',
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Permissions
    const allow = index_1.rule()(() => {
        throw new Error('external');
    });
    const permissions = index_1.shield({
        Query: allow,
    }, {
        allowExternalErrors: true,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.is(res.data, null);
    t.is(res.errors[0].message, 'Not Authorised!');
}));
ava_1.default('Custom error in rule resolves in custom error.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String!
    }
  `;
    const resolvers = {
        Query: {
            test: () => 'pass',
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Permissions
    const error = new Error(`${Math.random()}`);
    const allow = index_1.rule()(() => {
        return error;
    });
    const permissions = index_1.shield({
        Query: allow,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.is(res.data, null);
    t.is(res.errors[0].message, error.message);
}));
ava_1.default('Return original error in debug mode when error occurs in rule.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String!
    }
  `;
    const resolvers = {
        Query: {
            test: () => 'pass',
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Permissions
    const allow = index_1.rule()(() => {
        throw new Error('debug');
    });
    const permissions = index_1.shield({
        Query: allow,
    }, {
        debug: true,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.is(res.data, null);
    t.is(res.errors[0].message, 'debug');
}));
ava_1.default('Return original error in debug mode when error occurs in resolver.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String!
    }
  `;
    const resolvers = {
        Query: {
            test: () => {
                throw new Error('debug');
            },
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Permissions
    const allow = index_1.rule()(() => {
        return true;
    });
    const permissions = index_1.shield({
        Query: allow,
    }, {
        debug: true,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.is(res.data, null);
    t.is(res.errors[0].message, 'debug');
}));
ava_1.default('Correctly converts string fallback to error fallback.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String!
    }
  `;
    const resolvers = {
        Query: {
            test: () => {
                throw new Error();
            },
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Fallback
    const fallbackMessage = 'fallback';
    // Permissions
    const permissions = index_1.shield({
        Query: index_1.allow,
    }, {
        fallback: fallbackMessage,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.is(res.data, null);
    t.is(res.errors[0].message, fallbackMessage);
}));
ava_1.default('Correctly converts string fallbackError to error fallbackError.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Schema
    const typeDefs = `
    type Query {
      test: String!
    }
  `;
    const resolvers = {
        Query: {
            test: () => {
                throw new Error();
            },
        },
    };
    const schema = graphql_tools_1.makeExecutableSchema({
        typeDefs,
        resolvers,
    });
    // Fallback
    const fallbackMessage = 'fallback';
    // Permissions
    const permissions = index_1.shield({
        Query: index_1.allow,
    }, {
        fallbackError: fallbackMessage,
    });
    const schemaWithPermissions = graphql_middleware_1.applyMiddleware(schema, permissions);
    // Execution
    const query = `
    query {
      test
    }
  `;
    const res = yield graphql_1.graphql(schemaWithPermissions, query);
    t.is(res.data, null);
    t.is(res.errors[0].message, fallbackMessage);
}));
ava_1.default('Throws if both fallback and fallbackError are specified.', (t) => __awaiter(this, void 0, void 0, function* () {
    // Fallback
    const fallbackMessage = 'fallback';
    // Permissions
    t.throws(() => {
        index_1.shield({
            Query: index_1.allow,
        }, {
            fallback: fallbackMessage,
            fallbackError: new Error('fallbackError'),
        });
    }, {
        message: 'You specified both `fallback` and `fallbackError`. Please use one or the other.',
    });
}));
//# sourceMappingURL=error.test.js.map