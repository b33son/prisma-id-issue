"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const constructors_1 = require("./constructors");
const utils_1 = require("./utils");
const validation_1 = require("./validation");
const graphiql_1 = require("./graphiql");
/**
 *
 * @param options
 *
 * Generates a middleware function from a given rule and
 * initializes the cache object in context.
 *
 */
function generateFieldMiddlewareFromRule(rule, options) {
    function middleware(resolve, parent, args, ctx, info) {
        return __awaiter(this, void 0, void 0, function* () {
            // Cache
            if (!ctx) {
                ctx = {};
            }
            if (!ctx._shield) {
                ctx._shield = {};
            }
            if (!ctx._shield.cache) {
                ctx._shield.cache = {};
            }
            // Execution
            try {
                const res = yield rule.resolve(parent, args, ctx, info, options);
                if (res === true) {
                    return resolve(parent, args, ctx, info);
                }
                else if (res === false) {
                    return options.fallbackError;
                }
                else {
                    return res;
                }
            }
            catch (err) {
                if (options.debug) {
                    throw err;
                }
                else if (options.allowExternalErrors) {
                    return err;
                }
                else {
                    return options.fallbackError;
                }
            }
        });
    }
    if (utils_1.isRule(rule) && rule.extractFragment()) {
        return {
            fragment: rule.extractFragment(),
            resolve: middleware,
        };
    }
    else if (utils_1.isLogicRule(rule)) {
        return {
            fragments: rule.extractFragments(),
            resolve: middleware,
        };
    }
    else {
        return middleware;
    }
}
/**
 *
 * @param type
 * @param rules
 * @param options
 *
 * Generates middleware from rule for a particular type.
 *
 */
function applyRuleToType(type, rules, options) {
    if (utils_1.isRuleFunction(rules)) {
        const fieldMap = type.getFields();
        const middleware = Object.keys(fieldMap).reduce((middleware, field) => {
            return Object.assign({}, middleware, { [field]: generateFieldMiddlewareFromRule(rules, options) });
        }, {});
        return middleware;
    }
    else if (utils_1.isRuleFieldMap(rules)) {
        const fieldMap = type.getFields();
        // Validation
        const fieldErrors = Object.keys(rules)
            .filter(type => !Object.prototype.hasOwnProperty.call(fieldMap, type))
            .map(field => `${type.name}.${field}`)
            .join(', ');
        if (fieldErrors.length > 0) {
            throw new validation_1.ValidationError(`It seems like you have applied rules to ${fieldErrors} fields but Shield cannot find them in your schema.`);
        }
        // Generation
        const middleware = Object.keys(fieldMap).reduce((middleware, field) => {
            if (rules[field]) {
                return Object.assign({}, middleware, { [field]: generateFieldMiddlewareFromRule(rules[field], options) });
            }
            else {
                return Object.assign({}, middleware, { [field]: generateFieldMiddlewareFromRule(options.whitelist ? constructors_1.deny : options.fallbackRule, options) });
            }
        }, {});
        return middleware;
    }
    else {
        const fieldMap = type.getFields();
        const middleware = Object.keys(fieldMap).reduce((middleware, field) => {
            if (options.graphiql && graphiql_1.isGraphiQLType(type)) {
                return Object.assign({}, middleware, { [field]: generateFieldMiddlewareFromRule(constructors_1.allow, options) });
            }
            else {
                return Object.assign({}, middleware, { [field]: generateFieldMiddlewareFromRule(options.whitelist ? constructors_1.deny : options.fallbackRule, options) });
            }
        }, {});
        return middleware;
    }
}
/**
 *
 * @param schema
 * @param rule
 * @param options
 *
 * Applies the same rule over entire schema.
 *
 */
function applyRuleToSchema(schema, rule, options) {
    const typeMap = schema.getTypeMap();
    const middleware = Object.keys(typeMap).reduce((middleware, typeName) => {
        const type = typeMap[typeName];
        if (graphql_1.isObjectType(type)) {
            return Object.assign({}, middleware, { [typeName]: applyRuleToType(type, rule, options) });
        }
        else {
            return middleware;
        }
    }, {});
    return middleware;
}
/**
 *
 * @param rules
 * @param wrapper
 *
 * Converts rule tree to middleware.
 *
 */
function generateMiddlewareFromSchemaAndRuleTree(schema, rules, options) {
    if (utils_1.isRuleFunction(rules)) {
        return applyRuleToSchema(schema, rules, options);
    }
    else {
        const typeMap = schema.getTypeMap();
        // Validation
        const typeErrors = Object.keys(rules)
            .filter(type => !Object.prototype.hasOwnProperty.call(typeMap, type))
            .join(', ');
        if (typeErrors.length > 0) {
            throw new validation_1.ValidationError(`It seems like you have applied rules to ${typeErrors} types but Shield cannot find them in your schema.`);
        }
        // Generation
        const middleware = Object.keys(typeMap)
            .filter(type => graphql_1.isObjectType(typeMap[type]))
            .reduce((middleware, type) => (Object.assign({}, middleware, { [type]: applyRuleToType(typeMap[type], rules[type], options) })), {});
        return middleware;
    }
}
/**
 *
 * @param ruleTree
 * @param options
 *
 * Generates middleware from given rules.
 *
 */
function generateMiddlewareGeneratorFromRuleTree(ruleTree, options) {
    const generator = (schema) => {
        const middleware = generateMiddlewareFromSchemaAndRuleTree(schema, ruleTree, options);
        return middleware;
    };
    return generator;
}
exports.generateMiddlewareGeneratorFromRuleTree = generateMiddlewareGeneratorFromRuleTree;
//# sourceMappingURL=generator.js.map